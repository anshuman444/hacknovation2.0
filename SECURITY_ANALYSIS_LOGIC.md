# Security Analysis Logic & Basis

This document explains the technical heuristics and patterns used by the **Cartesi Analyzer** to identify vulnerabilities in smart contracts.

## 1. Reentrancy Risk
**Basis**: Detecting unsafe external calls without reentrancy guards.
- **Pattern**: The scanner looks for `.call{value: ...}`, `.send()`, or `.transfer()` patterns.
- **Heuristic**: If the contract performs one of these transfers but does *not* contain the strings `ReentrancyGuard` or `nonReentrant` (from OpenZeppelin), it flags a **HIGH** risk.
- **Vulnerability**: This is the basis for the classic reentrancy attack (like the DAO hack), where an attacker can recursively call the withdrawal function before the balance is updated.

## 2. Integer Overflow / Underflow
**Basis**: Checking for legacy compiler versions without built-in safety.
- **Pattern**: The scanner identifies the `pragma solidity` version.
- **Heuristic**: If the version is below `0.8.0` and the contract does *not* use the `SafeMath` library, it flags a **MEDIUM** risk.
- **Vulnerability**: Before Solidity 0.8.0, arithmetic operations (like `+` or `-`) could wrap around. An attacker could exploit this to overflow their balance or underflow a debt to a massive number.

## 3. Dangerous selfdestruct
**Basis**: Identifying potential contract destruction points.
- **Pattern**: The scanner searches for the keyword `selfdestruct`.
- **Heuristic**: Any use of `selfdestruct` is flagged as a **HIGH** risk/Critical mechanism, regardless of ownership checks.
- **Vulnerability**: If `selfdestruct` is accessible to an unauthorized user, the entire contract and its held funds can be permanently deleted.

## 4. Phishing via tx.origin
**Basis**: Misuse of global transaction variables for authentication.
- **Pattern**: The scanner detects the use of `tx.origin`.
- **Heuristic**: Usage of `tx.origin` for any logic is flagged as a **MEDIUM** risk phishing vulnerability.
- **Vulnerability**: Using `tx.origin` for authentication enables phishing attacks where a victim can be tricked into calling a malicious contract that then authorizes a transaction on the victim's behalf to the vulnerable contract.

## Deterministic Verification via Cartesi
Because these checks are performed inside a **Cartesi Machine**:
1. The analysis is **Deterministic**: Given the same code, it *always* produces the same security report.
2. The analysis is **Verifiable**: You can prove to anyone that the report was generated by this specific logic without them needing to trust your server.
